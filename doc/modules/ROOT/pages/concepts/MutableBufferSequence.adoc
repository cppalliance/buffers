//
// Copyright (c) 2024 Mohammad Nejati
// Copyright (c) 2025 Vinnie Falco
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// Official repository: https://github.com/cppalliance/buffers
//


= MutableBufferSequence

A mutable buffer sequence represents zero or more contiguous memory regions
as a bidirectional range whose value type is convertible to cpp:const_buffer[].

== Related Identifiers

cpp:mutable_buffer[], cpp:is_mutable_buffer_sequence[], cpp:begin[], cpp:end[]

== Requirements

* `T` denotes a type meeting the requirements of _MutableBufferSequence_.
* `t` denotes a (possibly const) value of type `T`.
* `u` denotes an identifier.
* `It` is the type `decltype(buffers::begin(t))`.

[cols="1a,1a,3a"]
|===
|Expression|Type|Semantics, Pre/Post-conditions

|`std::iterator_traits<It>::value_type`
|
|Convertible to cpp:const_buffer[].

|`It`
|
|
Requirements
[source,cpp]
----
requires std::bidirectional_iterator<It>
----

|`begin(t)`
|`It`
|Returns an iterator to the first element of the sequence.

|`end(t)`
|`It`
|Returns an iterator one past the last element of the sequence.

|`T u(t)`;
|
|
Requirements
[source,cpp]
----
requires
    std::copy_constructible<T> &&
    std::destructible<T>
----

Post-conditions:
[source,cpp]
----
assert( std::ranges::size(t) == std::ranges::size(u) );

for( auto [l, r] : std::views::zip( t, u ) )
{
    assert( l.data() == r.data() );
    assert( l.size() == r.size() );
}
----

|===


== Models

* cpp:const_buffer[]
* cpp:const_buffer_pair[]
* cpp:mutable_buffer[]
* cpp:mutable_buffer_pair[]
* cpp:slice_of[]
